# 1.카프카 소개 및 개요

[카프카 공식 홈페이지](https://kafka.apache.org/)

> Apache Kafka is an open-source distributed event streaming platform used by thousands of companies for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications.


카프카는 고성능 데이터 파이프라인, 스트리밍, 분석, 데이터 통합을 위해 수천개의 회사에서 사용되는 오픈소스 기반의 `분산 이벤트 스트리밍 플랫폼`입니다.


## 기본 구조

* Zookeeper: 카프카 Cluster를 관리한다.
* Cluster: 여러개의 Broker가 모여 하나처럼 동작하는 클러스터링된 단위다. 
* Broker: 메시지를 처리하는 서버역할
* Producer: 메시지를 카프카에 넣어주는 역할
* Consumer: 카프카로부터 메시지를 받아서 처리하는 역할

## 토픽과 파티션
* 토픽: 메시지를 구분하는 단위(파일시스템의 폴더, 디렉토리와 유사)
* 파티션: 한 개의 토픽이 구성하기위해 저장하는 물리적인 파일, 한 개의 토픽은 한 개 이상의 파티션으로 구성된다.

`카프카는 토픽과 파티션 단위로 메시지를 주고 받는다.`

## 파티션의 오프셋, 메시지 순서
* ***파티션***은 추가만 가능한(Append-Only)파일이다.
* 프로듀서가 넣은 메시지는 파티션의 맨 뒤에 추가한다.
* 컨슈머는 오프셋 기준으로 메시지를 순서대로 읽는다. (한 파티션내에서만 순서가 보장된다.)
* 메시지는 삭제되지 않는다.(설정에 따라 일정 시간이 지난 뒤에 삭제)

## 여러 파티션과 프로듀서의 동작
* ***프로듀서***는 라운드로빈 또는 키로 파티션을 선택한다.
* 같은 키를 갖는 메시지는 같은 파티션에 저장한다. -> 같은 키는 순서를 유지한다.

## 여러 파티션과 컨슈머
* 컨슈머는 컨슈머그룹에 속한다.
* 한 개 파티션은 컨슈머그룹의 한 개 컨슈머만 연결 가능하다.
    * 즉 컨슈머 그룹에 속한 컨슈머들은 한 파티션을 공유할 수 없다.
    * 한 컨슈머그룹 기준으로 파티션의 메시지는 순서대로 처리된다. 

## 성능
카프카는 소개에서 고성능이라는 특징을 강조하고있다. 왜 카프카의 성능이 좋은지 알아보자.

### 1. 파티션 파일은 OS 페이지캐시 사용
* 파티션에 대한 파일 IO를 메모리에서 처리
* 서버에서 페이지캐시를 카프카만 사용해야 성능에 유리
### 2. Zero Copy
* 디스크 버퍼에서 네트워크 버퍼로 직접 데이터 복사
### 3. 컨슈머 추적을 위해 브로커가 하는 일이 비교적 단순
* 메시지 필터, 메시지 재전송과 같은 일은 브로커가 하지 않는다.(프로듀서, 컨슈머가 직접처리)
* 브로커는 단순히 컨슈머와 파티션 간 매핑을 관리한다.
### 4. 배치(Batch)처리
* 프로듀서: 일정 크기만큼 메시지를 모아서 전송가능
* 컨슈머: 최소 크기만큼 메시지를 모아서 처리가능
`낱개 처리보다 처리량 증가`
### 5. 처리량 증대(확장)이 쉬움
* 1개 장비의 용량 한계 -> 브로커 추가, 파티션 추가
* 컨슈머가 느림 -> 컨슈머 및 파티션 추가

## 리플리카(Replica) - 복제
* 리플리카: 파티션의 복제본
    * 복제수(Replica factor)만큼 파티션의 복제본이 각 브로커에 생김
* 리더와 팔로워로 구성
    * 프로듀서와 컨슈머는 리더를 통해서만 메시지를 처리
    * 팔로워는 리더로부터 복제된다.
* 장애 대응
    * 리더가 속한 브로커 장애시 다른 팔로워가 리더가 된다.
`이를 통해 카프카는 고가용성을 보장한다.`